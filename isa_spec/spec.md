Этот файл Markdown содержит описание спецификации `Spec.isa`, используемой в игре Turing Complete. Эта спецификация
определяет язык для инструкций ассемблера.

***

# Spec.isa: Спецификация Архитектуры Набора Инструкций (ISA)

Спецификация ISA (`spec.isa`) — это язык, используемый для определения инструкций ассемблера в Turing Complete. Файлы
спецификаций ISA хранятся вместе со схемами в папке сохранения игрока под именем `spec.isa`.

Файл спецификации ISA состоит из нескольких разделов, ограниченных заголовками разделов, заключенными в квадратные
скобки (`[]`).

## Утилиты

Разработчик Stuffe выпустил утилиту для синтаксического анализа, компиляции, декомпиляции и выполнения других операций
со спецификациями ISA, доступную по адресу: `https://github.com/Stuffe/isa_spec`.

***

## [settings] (Настройки)

Раздел `[settings]` определяет несколько конфигурационных свойств для ISA.

| Настройка          | Описание                                                                                         | Синтаксис/Пример                            |
|:-------------------|:-------------------------------------------------------------------------------------------------|:--------------------------------------------|
| **name**           | Называет архитектуру. Может быть строкой или идентификатором.                                    | `name = "Architecture name"`                |
| **variant**        | Дополнительный текст для описания ISA.                                                           | `variant = "Architecture variant"`          |
| **endianness**     | Определяет порядок байтов инструкций. По умолчанию используется `big` endian.                    | `endianness = big`<br>`endianness = little` |
| **line_comments**  | Определяет токены для однострочных комментариев (от токена до конца строки).                     | `line_comments = "#"`                       |
| **block_comments** | Определяет токены для начала и конца блочного комментария. Комментарии не могут быть вложенными. | `block_comments = {"/*":"*/"}`              |

**Детали по `endianness`**:
Если инструкция определена как `11110000 00001111`, то `big` endian закодирует её как `240 15`, а `little` endian — как
`15 240`. Компоненты памяти (ROM, RAM и т.д.) имеют собственный флаг endianness.

**Детали по комментариям**:

* Значение по умолчанию для `line_comments` — `[";", "//"]`.
* Значение по умолчанию для `block_comments` — `{"/*":"*/"}`.
* Для синтаксиса списков (`line_comments`, `block_comments`) можно использовать скобки `[]`, `()` или `{}`.
* Компилятор учитывает эти настройки, но подсветка синтаксиса в окне ассемблера распознает только токены по умолчанию
  для однострочных комментариев и не распознает блочные комментарии вообще.

***

## [fields] (Поля)

Раздел `[fields]` определяет типы полей, которые могут быть включены в определения инструкций, а также их допустимые
значения.

* Поля разделяются пустыми строками.
* Каждое поле начинается с имени поля на первой строке, за которым следуют одно или несколько допустимых значений поля.
* Значениями являются битовые шаблоны, и все значения внутри поля должны иметь одинаковую битовую длину.
* Поля могут иметь любую ширину больше нуля.

**Особенности полей:**

* Имена полей и меток произвольны (например, `register` или `condition_code`).
* Допускается повторение значений (например, `in 110 out 110`).
* Не требуется, чтобы все возможные битовые шаблоны были назначены (например, `111` может быть не назначен).
* Поддерживается "литеральный" синтаксис для требования включения строки в инструкцию (например, `pound "#" 0`).
* Использование `""` позволяет использовать пустую строку, что делает поле фактически необязательным.

**Зарезервированные имена полей:**

1. **`label`**: Ссылается на метки внутри ассемблера (например, `mylabel:`).
2. **`immediate`**: Ссылается на непосредственные (иммедиатные) значения (например, `37`).

### Регистрные соглашения

В целях указания предпочтений компилятору можно добавить следующие секции:

```
[register_prefs]
lhs = r1
rhs = r2
result = r3
```

```
[special_registers]
zr = r0
sp = r14
flags = r15
immediate = r16
```

Эти блоки опциональны; если их нет, используются любые доступные регистры. Специальный регистр `immediate` резервируется
для загрузки иммедиатных значений: компилятор сначала помещает литерал в него, а затем перемещает в нужный рабочий
регистр.

***

## [instructions] (Инструкции)

Раздел `[instructions]` определяет сами инструкции. Инструкции разделены пустой строкой и состоят из нескольких
компонентов:

1. Формат ассемблера (Assembly format).
2. Виртуальные операнды (Virtual operands).
3. Утверждения (Assertions).
4. Выходной битовый шаблон (Output bit pattern).
5. Необязательная строка описания (Description line).

### 1. Assembly Format (Формат ассемблера)

Это строка токенов, разделенных пробелами (литералы или операнды).

#### Литералы

Литерал (например, `div` или запятые `,`) должен быть набран пользователем точно, чтобы инструкция была сопоставлена.

* Для использования символа `%` как литерала необходимо использовать диграф `%%`.
* Нельзя использовать токены комментариев в качестве литералов, так как они будут обрабатываться ассемблером как
  комментарии.
* **Пробелы**: Один символ пробела делает пространство опциональным. Два пробела или более делают пространство
  обязательным между токенами.

#### Операнды Инструкций (Instruction Operands)

Операнды начинаются с префикса `%` и записываются в форме `%name:size(fields)`:

* **`name`**: Обязательный идентификатор (например, `%a`).
* **`size`**: Необязательный (включая предшествующее двоеточие). `S` для знаковых или `U` для беззнаковых значений, за
  которым следует размер в битах (например, `S32`). По умолчанию — `U64`, максимальный размер — 64 бита.
* **`fields`**: Обязательный список полей (определенных в разделе `[fields]` или зарезервированных). Список полей
  разделяется символом вертикальной черты (`|`).

### 2. Virtual Operands (Виртуальные операнды)

Дополнительные операнды, созданные для упрощения инструкций или обеспечения гарантий корректности во время компиляции.

Синтаксис: `%name:size = expression`.

* Выражения используют математические операторы, подобные C, и встроенные функции.
* Выражения вычисляются во время ассемблирования. **Нельзя использовать значения времени выполнения**, такие как
  содержимое регистров или памяти; вместо этого будет получен индекс или адрес.

#### Операторы Выражений:

Поддерживаются бинарные операторы: `+`, `-`, `*`, `/`, `%`, `&` (AND), `|` (OR), `^` (XOR), `<<` (LSL), `>>` (LSR).

* Отсутствующие унарные операторы могут быть реализованы: Bitwise NOT (`~%a`) как `(-1 ^ %a)`; Negation (`-%a`) как
  `(0 - %a)`.

**Приоритет Операторов:**

1. Скобки `()`
2. Мультипликативные `*`, `/`, `%`
3. Все остальные `+`, `-`, `&`, `|`, `^`, `<<`, `>>`

#### Функции:

* `asr`: Арифметический сдвиг вправо.
* `log2`: Пол логарифма по основанию 2 (или -1, если значение ≤ 0).
* `popcount`: Количество единиц в битовом представлении.
* `trailing_zeros`: Количество нулей после самого правого единичного бита.

#### Битовое Нарезание (Bit Slicing) в выражениях:

Синтаксис: `value[start:end]`

* `start` и `end` являются инклюзивными индексами битов `value`. LSB (младший значащий бит) имеет индекс 0.
* `start` должен быть больше, чем `end`. Например, `%imm[5:2]` на значении `0b01011010` (90) даст `0b0110` (6).

#### Адрес Инструкции

Специальный символ `$` возвращает адрес памяти начала текущей инструкции, что полезно для относительных переходов.

### 3. Assertions (Утверждения)

Утверждения могут быть перемешаны с виртуальными операндами и вызывают ошибку, если они не истинны.

Синтаксис: `!assert <lhs> == <rhs>`.

* В настоящее время поддерживается только оператор сравнения `==` (равно).
* После сравнения может быть добавлена строка для вывода более контекстно-специфичного сообщения об ошибке.

### 4. Output Bit Pattern (Выходной битовый шаблон)

Шаблон следует за виртуальными операндами или утверждениями. Он определяет последовательность битов, интерпретируемую
как единое число в формате big-endian (которое затем переупорядочивается в соответствии с настройкой endianness).
Пробелы (и только пробелы) игнорируются.

#### Фиксированные шаблоны

* **`0`** и **`1`**: Производят эти биты на выходе и требуют их точного наличия при дизассемблировании.
* **`?`**: Производит `0` при ассемблировании, но игнорируется при дизассемблировании.

#### Индивидуальные Буквы (Shortcuts)

Строчные буквы используются как сокращения для операндов. Буква ссылается на первый операнд, начинающийся с этой буквы,
в порядке слева направо в строке синтаксиса, а затем сверху вниз для виртуальных операндов.

* Если буква появляется несколько раз, все эти появления назначаются битам, как если бы они были одним большим полем.
  Биты назначаются от LSB к MSB повторяющимся буквам в порядке справа налево.
* Если значение операнда короче, чем длина поля, оно будет расширено знаком (для знаковых операндов) или заполнено
  нулями (для беззнаковых операндов).
* Поля, которые длиннее, чем их выходной формат, приведут к ошибке.

#### Явные Ссылки на Операнды (Slicing)

Операнды могут быть указаны по полному имени с использованием префикса `%` и указанием, какие биты использовать, с
синтаксисом, подобным нарезанию:

Синтаксис: `%operand[start:end]`.

* `operand` должно быть именем операнда (инструкции или виртуального).
* `start` и `end` должны быть беззнаковыми целочисленными литералами.
* Аналогично индивидуальным буквам, более короткие значения будут расширены знаком или нулями.

### 5. Description (Описание)

Описание инструкции — это одна строка, содержащая любой текст без синтаксических ограничений. Многострочные описания в
настоящее время невозможны.

***

## Addendum: Masking (Маскирование)

Маскирование — это операция, используемая для извлечения одного или нескольких индивидуальных битов из большего числа,
часто как способ предотвращения ошибок из-за несовпадения битовых ширин.

Операция выполняется путем **применения побитового AND** к извлекаемому значению с *маской* (второе число, содержащее
`1` в позициях, которые нужно извлечь, и `0` в остальных).

**Извлечение и Сдвиг**:
Если извлеченные биты находятся не в младших позициях, необходимо выполнить дополнительную операцию сдвига вправо:

```
%masked = (%value & 0b11110000) >> 4 
```

Синтаксис битового нарезания в виртуальных операндах (`%value[7:4]`) выполняет эту операцию автоматически, без
необходимости ручного сдвига.

**Конструирование маски**:
Маски могут быть созданы с помощью сдвигов и побитовых OR.
Например, маска с установленным 38-м битом: `%mask = 1 << 38` (отсчет начинается с 0).
Чтобы установить все младшие $N$ битов, используется свойство: `%mask = (1 << N) - 1` (например, `(1<<39)-1` вернет
маску с 39 младшими битами, установленными в `1`).
